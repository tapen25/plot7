<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tamacoro Style Interaction</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #111; color: #eee; text-align: center; padding: 20px; overflow: hidden; }
        h1 { font-size: 1.5rem; letter-spacing: 2px; text-transform: uppercase; color: #ff0055; }
        p { font-size: 0.9rem; color: #888; }
        
        #startBtn { 
            padding: 20px 60px; font-size: 1.2rem; font-weight: bold;
            background: linear-gradient(45deg, #ff0055, #ff5500); 
            border: none; color: #fff; border-radius: 50px; 
            cursor: pointer; margin-top: 40px; box-shadow: 0 0 20px rgba(255, 0, 85, 0.5);
            transition: transform 0.1s;
        }
        #startBtn:active { transform: scale(0.95); }

        #visualizer {
            margin: 40px auto;
            width: 200px; height: 200px;
            border-radius: 50%;
            background: radial-gradient(circle, #333, #000);
            border: 2px solid #555;
            display: flex; justify-content: center; align-items: center;
            position: relative;
            transition: all 0.1s;
        }
        
        #status-text { position: absolute; z-index: 10; font-weight: bold; font-size: 1.5rem; text-shadow: 0 0 10px #000; }
        
        .hud { margin-top: 30px; display: flex; justify-content: space-around; font-family: monospace; font-size: 0.9rem; }
        .hud div span { display: block; font-size: 1.2rem; color: #ff5500; }
    </style>
</head>
<body>

    <h1>Rolling Gizmo Style</h1>
    <p>スマホを持って「START」を押し、<br>ボールに乗っているつもりで振ってください。</p>
    
    <div id="visualizer">
        <div id="status-text">STOP</div>
    </div>

    <button id="startBtn">START</button>
    
    <div class="hud">
        <div>SPEED<span id="speedVal">0%</span></div>
        <div>BPM<span id="bpmVal">0</span></div>
        <div>PITCH<span id="pitchVal">+0</span></div>
    </div>

<script>
// ==========================================
// 1. システム設定
// ==========================================
const MOTION_BUFFER_SIZE = 10;
const motionBuffer = []; 
let currentActivity = 0.0; // 0.0(静止) 〜 1.0(最大)
let smoothedActivity = 0.0;

// ステージ管理
// 0.0-0.3: Low (Filter Close, BassOnly)
// 0.3-0.7: Mid (Filter Open, +Chords)
// 0.7-1.0: High (High BPM, High Pitch, +Arp +Wind)

// ==========================================
// 2. 音源設定 (Tone.js)
// ==========================================
let masterFilter;
let kick, bass, chordSynth, arpSynth, windNode;
let chordVol, arpVol, windVol; // Gain Nodes for Layering

function setupAudio() {
    // A. マスターエフェクト (LPF: こもり具合の制御)
    masterFilter = new Tone.Filter({
        type: "lowpass",
        frequency: 200, // 初期値はこもった音
        Q: 1
    }).toDestination();
    
    // 全体のリミッター（音割れ防止）
    const limiter = new Tone.Limiter(-1).connect(masterFilter);

    // B. 各楽器のセットアップ
    
    // 1. KICK & BASS (常時鳴る)
    kick = new Tone.MembraneSynth({
        volume: -2,
        envelope: { sustain: 0, attack: 0.02, decay: 0.8 },
        octaves: 10
    }).connect(limiter);

    bass = new Tone.FMSynth({
        volume: -5,
        harmonicity: 1,
        modulationIndex: 3.5,
        oscillator: { type: "custom", partials: [0,1,0,2] },
        envelope: { attack: 0.08, decay: 0.3, sustain: 1, release: 0.5 },
        modulation: { type: "square" },
        modulationEnvelope: { attack: 0.1, decay: 0.2, sustain: 0.2, release: 0.5 }
    }).connect(limiter);

    // 2. CHORDS (中盤からフェードイン)
    chordVol = new Tone.Gain(0).connect(limiter);
    chordSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -8,
        oscillator: { type: "sawtooth" }, // 派手めな音
        envelope: { attack: 0.1, decay: 0.1, sustain: 0.6, release: 0.8 }
    }).connect(chordVol);

    // 3. ARPEGGIO (終盤で入るキラキラ音)
    arpVol = new Tone.Gain(0).connect(limiter);
    arpSynth = new Tone.AMSynth({
        volume: -8,
        harmonicity: 2.5,
        oscillator: { type: "fatsawtooth" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
        modulation: { type: "square", modulationIndex: 3 }
    }).connect(arpVol);

    // 4. WIND NOISE (速度に応じた風)
    windVol = new Tone.Gain(0).connect(limiter);
    const windFilter = new Tone.Filter(800, "bandpass").connect(windVol);
    windNode = new Tone.Noise("pink").connect(windFilter);
    windNode.start(); // ノイズはずっと流しておく(Gainで制御)
}

// ==========================================
// 3. 音楽ロジック (シーケンス)
// ==========================================
// キー: F Minor (疾走感のあるキー)
const scale = ["F2", "G2", "Ab2", "Bb2", "C3", "Db3", "Eb3"];
const chordProgression = [
    ["F3","Ab3","C4"], ["Eb3","G3","Bb3"], ["Db3","F3","Ab3"], ["C3","E3","G3"] // Fm - Eb - Db - C
];
let tick = 0;

function startSequencer() {
    Tone.Transport.bpm.value = 100;

    Tone.Transport.scheduleRepeat((time) => {
        // 現在のアクティビティに基づいて「移調 (Transpose)」を計算
        // 0.0なら0, 1.0なら+12(1オクターブ上)
        const transpose = Math.floor(smoothedActivity * 12); 
        
        const beat = tick % 16;
        const bar = Math.floor(tick / 16) % 4;

        // --- Bass & Kick (常に鳴る) ---
        if (beat % 4 === 0) {
            kick.triggerAttackRelease("F1", "8n", time);
        }
        if (beat === 2 || beat === 10) { // 裏打ちベース
             const bassNote = Tone.Frequency(scale[0]).transpose(transpose);
             bass.triggerAttackRelease(bassNote, "8n", time);
        }
        
        // --- Chords (Level 2~) ---
        if (beat === 0) {
            // コードを移調して鳴らす
            const currentChord = chordProgression[bar].map(n => Tone.Frequency(n).transpose(transpose));
            chordSynth.triggerAttackRelease(currentChord, "2n", time);
        }

        // --- Arpeggio (Level 3~) ---
        // 16分音符でランダムに鳴らす
        if (smoothedActivity > 0.6) {
            if (Math.random() > 0.3) {
                // スケールからランダム選出 + 移調 + オクターブ上げ
                const noteRaw = scale[Math.floor(Math.random() * scale.length)];
                const note = Tone.Frequency(noteRaw).transpose(transpose + 12); 
                arpSynth.triggerAttackRelease(note, "16n", time);
            }
        }

        tick++;
    }, "16n");

    Tone.Transport.start();
}

// ==========================================
// 4. インタラクション制御ループ (Visual & Audio Param)
// ==========================================
function updateLoop() {
    requestAnimationFrame(updateLoop);
    
    if (!masterFilter) return;

    // A. スムージング処理 (急激な変化を防ぐ)
    smoothedActivity += (currentActivity - smoothedActivity) * 0.1;
    
    // B. パラメータマッピング
    
    // 1. フィルター (LPF Cutoff)
    // 静止時 200Hz(モコモコ) -> 最大 10000Hz(クリア)
    const cutoff = 200 + (Math.pow(smoothedActivity, 2) * 10000); 
    masterFilter.frequency.rampTo(cutoff, 0.1);

    // 2. BPM (Tempo)
    // 90 -> 170
    const targetBpm = 90 + (smoothedActivity * 80);
    Tone.Transport.bpm.rampTo(targetBpm, 0.1);

    // 3. レイヤーボリューム (Vertical Remixing)
    
    // Chords: 0.2を超えたら入り始める
    let cVol = (smoothedActivity - 0.2) * 2; 
    cVol = Math.max(0, Math.min(cVol, 0.8)); // 0.0 - 0.8
    chordVol.gain.rampTo(cVol, 0.1);

    // Arp: 0.5を超えたら入り始める
    let aVol = (smoothedActivity - 0.5) * 2;
    aVol = Math.max(0, Math.min(aVol, 0.6));
    arpVol.gain.rampTo(aVol, 0.1);

    // Wind: 速度に比例
    let wVol = smoothedActivity * 0.8;
    windVol.gain.rampTo(wVol, 0.1);

    // C. 画面更新
    const pct = Math.round(smoothedActivity * 100);
    document.getElementById('speedVal').innerText = pct + "%";
    document.getElementById('bpmVal').innerText = Math.round(Tone.Transport.bpm.value);
    document.getElementById('pitchVal').innerText = "+" + Math.floor(smoothedActivity * 12);
    
    const viz = document.getElementById('visualizer');
    const scale = 1 + (smoothedActivity * 0.5);
    const color = `hsl(${smoothedActivity * 60}, 100%, 50%)`; // 赤 -> 黄
    
    viz.style.transform = `scale(${scale})`;
    viz.style.borderColor = color;
    viz.style.boxShadow = `0 0 ${smoothedActivity * 50}px ${color}`;
    document.getElementById('status-text').innerText = pct < 10 ? "STOP" : (pct < 60 ? "ROLLING" : "DANGER!!");
    document.getElementById('status-text').style.color = color;
}


// ==========================================
// 5. センサー処理
// ==========================================
function handleMotion(event) {
    const a = event.accelerationIncludingGravity;
    if (!a) return;

    // ベクトルの大きさ変化量を見る（ハイパスフィルタ的な処理）
    // 直前の値との差分をとることで「動きの変化」を抽出
    const x = a.x || 0; const y = a.y || 0; const z = a.z || 0;
    const mag = Math.sqrt(x*x + y*y + z*z);
    
    motionBuffer.push(mag);
    if (motionBuffer.length > MOTION_BUFFER_SIZE) motionBuffer.shift();

    // 標準偏差(バラつき)を計算 = 揺れの激しさ
    const mean = motionBuffer.reduce((a,b)=>a+b,0) / motionBuffer.length;
    const variance = motionBuffer.reduce((a,b)=>a+Math.pow(b-mean,2),0) / motionBuffer.length;
    const stdDev = Math.sqrt(variance);

    // 感度調整: 0.0〜1.0に正規化
    // 激しく振ると stdDev は 5〜8 くらい行く
    const inputVal = Math.min(stdDev / 6.0, 1.0);
    
    currentActivity = inputVal;
}

// ==========================================
// 6. 初期化
// ==========================================
const btn = document.getElementById('startBtn');

btn.addEventListener('click', async () => {
    // iOS Permission
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const state = await DeviceMotionEvent.requestPermission();
        if (state !== 'granted') { alert("センサー許可が必要です"); return; }
    }
    
    window.addEventListener('devicemotion', handleMotion);
    
    await Tone.start();
    setupAudio();
    startSequencer();
    updateLoop();
    
    btn.style.display = 'none';
});

</script>
</body>
</html>