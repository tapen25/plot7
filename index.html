<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Motion Filter Synth</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
<style>
  body { font-family: sans-serif; padding: 20px; text-align: center; background: #f0f0f0; transition: background 0.5s; }
  button { padding: 15px 30px; font-size: 1.2em; cursor: pointer; border: none; background: #333; color: white; border-radius: 8px; }
  #status, #debug { margin: 15px 0; font-size: 1.2em; }
  #debug { color: #666; font-size: 0.9em; }
  .active { background: #e0f7fa; }
</style>
</head>
<body>

<button id="start">Start (iOSは要タップ)</button>
<div id="status">停止中</div>
<div id="debug">Filter: Closed</div>

<script>
// ==========================================
// 1. エフェクトとシンセの定義
// ==========================================

// ★ここが重要: 独立したフィルターを作る
// frequency: 初期値は 200Hz (かなりこもった音)
const globalFilter = new Tone.Filter({
  type: "lowpass",
  frequency: 200, 
  Q: 1 // レゾナンス（少しクセをつける）
}).toDestination();

// PolySynthをフィルターに接続 (.connect(globalFilter))
const polySynth = new Tone.PolySynth(Tone.Synth, {
  oscillator: { 
    type: "sawtooth" // ★重要: フィルターの効きが良いノコギリ波
  },
  envelope: { 
    attack: 0.1, 
    decay: 0.2, 
    sustain: 0.5, 
    release: 1 
  },
  volume: -5
}).connect(globalFilter); // 出力先をフィルターへ

// ==========================================
// 変数・設定
// ==========================================
let usePatternA = true;
let isPlaying = false; 
let currentNoteIndex = 0; 
let smoothedBPM = 60; 

let motionHistory = [];
const HISTORY_DURATION = 2000; 

const patterns = {
  A: ["D4","C4","B3","D4", "C4","A3", "G3","A3", "B3"],
  B: ["D4","C4","B3","D4", "C4","A3", "G3","B3", "G3"]
};

const durations = [0.25, 0.25, 0.25, 0.25, 0.5, 0.5, 0.5, 0.5, 1.0];

function noteToFreq(note) {
  const map = {
    G3: -14, A3: -12, B3: -10,
    C4: -9,  D4: -7,  E4: -5, F4: -4, G4: -2, A4: 0, B4: 2,
    C5: 3
  };
  let semitone = map[note] || 0;
  return 440 * Math.pow(2, semitone/12);
}

// ==========================================
// 開始処理
// ==========================================
document.getElementById("start").onclick = async () => {
  if (typeof DeviceMotionEvent.requestPermission === 'function') {
    try {
      const permissionState = await DeviceMotionEvent.requestPermission();
      if (permissionState !== 'granted') return alert("拒否されました");
    } catch (e) { console.error(e); }
  }

  await Tone.start();
  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "振ってフィルターを開放してください";
  document.getElementById("start").style.display = "none";
  document.body.classList.add("active");
};

// ==========================================
// センサー処理 & フィルター制御
// ==========================================
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;

  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({ time: now, val: mag });
  motionHistory = motionHistory.filter(item => now - item.time < HISTORY_DURATION);

  let sum = 0;
  motionHistory.forEach(item => sum += item.val);
  const avgMag = sum / motionHistory.length || 0;

  smoothedBPM = mapAccelToBPM(avgMag);
  
  // ★ここでフィルターの開き具合を制御します
  updateFilter(avgMag);

  if (!isPlaying && mag > 15) { 
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let bpm = 90 + (a - 10) * 5; 
  if (bpm < 60) bpm = 60;
  if (bpm > 180) bpm = 180;
  return bpm;
}

// フィルター制御関数
function updateFilter(magnitude) {
  // 揺れ(magnitude) 10(静止) 〜 30(激しい) を
  // 周波数 200Hz(こもる) 〜 3000Hz(開く) にマッピング
  
  // 最小値と最大値の定義
  const minFreq = 200;  // 完全にこもった音
  const maxFreq = 3000; // 明るく開いた音
  
  // マッピング計算
  let targetFreq = 200 + (magnitude - 10) * 150;
  
  // 範囲制限
  if (targetFreq < minFreq) targetFreq = minFreq;
  if (targetFreq > maxFreq) targetFreq = maxFreq;

  // rampToを使って滑らかに変化させる（0.1秒かけて変化）
  globalFilter.frequency.rampTo(targetFreq, 0.1);

  document.getElementById("debug").innerText = 
    `Filter: ${Math.floor(targetFreq)}Hz (BPM: ${Math.floor(smoothedBPM)})`;
}

// ==========================================
// シーケンス制御
// ==========================================
function startSequence() {
  isPlaying = true;
  currentNoteIndex = 0;
  playNextNote(); 
}

function playNextNote() {
  const currentPattern = usePatternA ? patterns.A : patterns.B;
  
  if (currentNoteIndex >= currentPattern.length) {
    finishSequence();
    return;
  }

  const noteName = currentPattern[currentNoteIndex];
  const durationVal = durations[currentNoteIndex];
  
  // テンポ計算
  const beatDuration = 60 / smoothedBPM; 
  const noteTimeLen = beatDuration * durationVal;
  
  // ★転調（pitchOffset）は削除しました
  const freq = noteToFreq(noteName);

  // 音を鳴らす（PolySynth固定）
  polySynth.triggerAttackRelease(freq, noteTimeLen);

  document.getElementById("status").innerText = 
    `再生中: ${usePatternA?"A":"B"} (${currentNoteIndex+1}/${currentPattern.length})`;

  setTimeout(() => {
    currentNoteIndex++;
    playNextNote(); 
  }, noteTimeLen * 1000); 
}

function finishSequence() {
  isPlaying = false;
  usePatternA = !usePatternA; 
  document.getElementById("status").innerText = "待機中...";
  // 演奏が終わったら少しフィルターを閉じる演出
  globalFilter.frequency.rampTo(200, 2);
}
</script>

</body>
</html>