<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Musical Wind & Arpeggio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { font-family: 'Helvetica Neue', Arial, sans-serif; background: #000; color: #fff; text-align: center; padding: 20px; overflow: hidden; user-select: none; }
        h1 { font-size: 1.2rem; color: #00d1b2; letter-spacing: 2px; text-transform: uppercase; }
        
        #playBtn {
            margin-top: 35vh;
            padding: 20px 60px; font-size: 1.2rem; font-weight: bold;
            color: #fff; background: linear-gradient(135deg, #00d1b2, #0077ff);
            border: none; border-radius: 50px;
            box-shadow: 0 0 20px rgba(0, 209, 178, 0.6); transition: transform 0.1s;
        }
        #playBtn:active { transform: scale(0.95); }

        .hud { position: absolute; top: 20px; width: 100%; display: flex; justify-content: center; gap: 20px; font-family: monospace; font-size: 1.2rem; z-index: 10;}
        .hud span { color: #00d1b2; }

        /* 風と速度のビジュアライザ */
        #wind-visual {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 200px; height: 200px; border-radius: 50%;
            border: 2px solid #333; opacity: 0.5; transition: all 0.1s; z-index: -1;
        }
    </style>
</head>
<body>

    <div class="hud">
        <div>SPEED: <span id="speedVal">0%</span></div>
    </div>

    <h1>Wind & Harmony</h1>
    <div id="wind-visual"></div>
    <button id="playBtn">START EXPERIENCE</button>

<script>
// ==========================================
// 1. システム設定
// ==========================================
let isPlaying = false;
let smoothedActivity = 0.0;
const BUFFER_SIZE = 10;
const motionBuffer = [];

// ==========================================
// 2. 音楽理論データ: コードトーン定義
// ==========================================
// 王道進行 (IV - V - iii - vi)
// キー: C Major (ハ長調)
const chords = [
    { name: "FM7", notes: ["F3", "A3", "C4", "E4"] }, // 0: Sub Dominant
    { name: "G7",  notes: ["G3", "B3", "D4", "F4"] }, // 1: Dominant
    { name: "Em7", notes: ["E3", "G3", "B3", "D4"] }, // 2: Tonic substitute
    { name: "Am7", notes: ["A3", "C4", "E4", "G4"] }  // 3: Tonic substitute
];

// 高速アルペジオ用（オクターブ上の音を追加した定義）
const arpeggioNotes = [
    ["F4", "A4", "C5", "E5", "F5", "A5"], // FM7 high
    ["G4", "B4", "D5", "F5", "G5", "B5"], // G7 high
    ["E4", "G4", "B4", "D5", "E5", "G5"], // Em7 high
    ["A4", "C5", "E5", "G5", "A5", "C6"]  // Am7 high
];

// ==========================================
// 3. 音源セットアップ
// ==========================================
let leadSynth, chordSynth, bassSynth, drumKit;
let windNode, windGain, windFilter;

function setupAudio() {
    // A. シンセサイザー類
    const limiter = new Tone.Limiter(-1).toDestination();

    // 1. リード (メロディ) - 澄んだ音
    leadSynth = new Tone.Synth({
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.3, release: 0.5 },
        volume: -6
    }).connect(limiter);

    // 2. コード (バッキング)
    chordSynth = new Tone.PolySynth(Tone.Synth, {
        oscillator: { type: "sine" },
        envelope: { attack: 0.1, decay: 0.2, sustain: 0.5, release: 1 },
        volume: -12
    }).connect(limiter);

    // 3. ベース
    bassSynth = new Tone.FMSynth({
        harmonicity: 1, modulationIndex: 3,
        envelope: { attack: 0.05, decay: 0.2, sustain: 0.8, release: 0.5 },
        volume: -6
    }).connect(limiter);

    // 4. ドラム
    drumKit = {
        kick: new Tone.MembraneSynth({ volume: -4 }).connect(limiter),
        hat: new Tone.MetalSynth({ frequency: 200, envelope: { decay: 0.05 }, volume: -20 }).connect(limiter)
    };

    // B. 風切り音 (Wind Noise) システム
    // ピンクノイズを生成し、バンドパスフィルターを通す
    windFilter = new Tone.Filter({
        type: "bandpass",
        frequency: 400,
        Q: 1
    });
    windGain = new Tone.Gain(0).connect(limiter); // 初期音量は0
    windNode = new Tone.Noise("pink").connect(windFilter).connect(windGain);
    windNode.start();
}

// ==========================================
// 4. 演奏シーケンサー
// ==========================================
let tick = 0;
// アルペジオの進行位置を記憶する変数
let arpIndex = 0; 

function startLoop() {
    Tone.Transport.bpm.value = 110;

    Tone.Transport.scheduleRepeat((time) => {
        const intensity = smoothedActivity; // 0.0 - 1.0
        
        const beat16 = tick % 16;
        const barIndex = Math.floor(tick / 16) % 4; // 0->1->2->3 (コード進行)
        const currentChord = chords[barIndex];

        // --- 1. コード演奏 (和音) ---
        // 常に鳴らして「音楽的基盤」を作る
        if (beat16 === 0) {
            chordSynth.triggerAttackRelease(currentChord.notes, "2n", time);
        }

        // --- 2. ベース ---
        // intensityが上がると少しリズミカルになる
        if (beat16 === 0) {
             // ルート音 (F3 -> F2)
             const root = currentChord.notes[0].replace("3","2").replace("4","3");
             bassSynth.triggerAttackRelease(root, "8n", time);
        }
        if (intensity > 0.5 && beat16 === 10) { // 裏打ち
             const root = currentChord.notes[0].replace("3","2").replace("4","3");
             bassSynth.triggerAttackRelease(root, "8n", time);
        }

        // --- 3. メロディ (今回の核心部分) ---
        playTheoreticalMelody(time, intensity, beat16, barIndex);

        // --- 4. ドラム ---
        // Kick
        if (beat16 % 4 === 0) drumKit.kick.triggerAttackRelease("C1", "8n", time);
        // Hat (速度に合わせて細かくなる)
        if (intensity < 0.3) {
            if (beat16 % 4 === 2) drumKit.hat.triggerAttackRelease("32n", time);
        } else if (intensity < 0.7) {
            if (beat16 % 2 === 0) drumKit.hat.triggerAttackRelease("32n", time);
        } else {
            // 高速時: 16分連打
            drumKit.hat.triggerAttackRelease("32n", time);
        }

        tick++;
    }, "16n");

    Tone.Transport.start();
}

// 音楽理論に基づいたメロディ生成関数
function playTheoreticalMelody(time, act, beat, chordIdx) {
    let noteToPlay = null;
    let duration = "8n";

    // A. 静寂〜歩き (Activity: 低)
    // ゆったりと、コードの構成音を「置く」ように鳴らす
    if (act < 0.3) {
        if (beat === 0 || beat === 8) { // 小節の頭と真ん中だけ
            // そのコードのルートか5度音だけを選ぶ（一番安定する音）
            if(Math.random() > 0.5) noteToPlay = chords[chordIdx].notes[0]; // Root
            else noteToPlay = chords[chordIdx].notes[2]; // 5th
        }
    } 
    // B. 小走り (Activity: 中)
    // 8分音符でランダムなフレーズ。ただしコードトーンのみ。
    else if (act < 0.7) {
        if (beat % 2 === 0) {
            if (Math.random() < 0.6) {
                // コード内の音からランダム
                const notes = chords[chordIdx].notes;
                noteToPlay = notes[Math.floor(Math.random() * notes.length)];
            }
        }
    } 
    // C. 疾走・暴走 (Activity: 高) -> ここを修正！
    // ランダムではなく「規則的なアルペジオ」にする
    else {
        // 16分音符ですべて埋める勢い
        duration = "16n";
        
        // 【重要】アルペジオロジック
        // ランダムだと「ぐちゃぐちゃ」になるので、順番に鳴らす
        // 例: ド -> ミ -> ソ -> ド -> ミ...
        const arpNotes = arpeggioNotes[chordIdx]; // 高音域のコードトーン配列
        
        // tickに合わせて音を選ぶ（順番に上昇していく）
        // これにより「テロリロテロリロ」というゲーム的で綺麗なフレーズになる
        const noteIndex = tick % arpNotes.length; 
        noteToPlay = arpNotes[noteIndex];
    }

    if (noteToPlay) {
        leadSynth.triggerAttackRelease(noteToPlay, duration, time);
    }
}

// ==========================================
// 5. 更新ループ (風の制御 & 画面)
// ==========================================
function update() {
    requestAnimationFrame(update);
    if(!isPlaying) return;

    // スムージング
    smoothedActivity += ((motionBuffer.length ? motionBuffer[motionBuffer.length-1] : 0) - smoothedActivity) * 0.05;
    // 0.0〜1.0の範囲にクランプ
    smoothedActivity = Math.max(0, Math.min(1, smoothedActivity));

    // --- 風 (Wind) の制御 ---
    // 1. 音量: 動きに合わせて大きくなる (0.0 -> 0.8)
    // 動きがないときは無音
    windGain.gain.rampTo(smoothedActivity * 0.8, 0.1);

    // 2. 音質: 動きが速いほど「高い音（ヒュオオ）」になる
    // Bandpass Frequency: 200Hz(ゴォー) -> 2000Hz(シュオオ)
    const windFreq = 200 + (smoothedActivity * 1800);
    windFilter.frequency.rampTo(windFreq, 0.1);

    // --- BPM制御 ---
    // 少しだけBPMも上げる (110 -> 140)
    // あまり上げすぎるとアルペジオが追いつかなくなるので控えめに
    Tone.Transport.bpm.rampTo(110 + (smoothedActivity * 30), 0.1);

    // 画面更新
    document.getElementById('speedVal').innerText = Math.round(smoothedActivity * 100) + "%";
    
    // ビジュアライザ更新
    const viz = document.getElementById('wind-visual');
    const scale = 0.5 + smoothedActivity * 1.5;
    const opacity = 0.2 + smoothedActivity * 0.6;
    viz.style.transform = `translate(-50%, -50%) scale(${scale})`;
    viz.style.opacity = opacity;
    // 風が強くなると色も変わる
    viz.style.borderColor = `hsl(${180 - smoothedActivity*60}, 100%, 50%)`; // 青緑 -> 青
    viz.style.borderWidth = `${2 + smoothedActivity * 10}px`;
}

// ==========================================
// 6. センサー入力
// ==========================================
function handleMotion(event) {
    const a = event.accelerationIncludingGravity;
    if (!a) return;
    
    const x = a.x || 0; const y = a.y || 0; const z = a.z || 0;
    // ベクトル長の変化を見る簡易ロジック
    // 直前の値との差分をとるのが理想だが、ここでは簡易的に絶対値のゆらぎを利用
    // スマホを傾けるだけでなく「振る」動作を検知したい
    
    // 重力加速度(約9.8)を除去して純粋なシェイク強度を取りたいが、
    // 簡易的に「全体の大きさ - 9.8」の絶対値などを使う
    const mag = Math.sqrt(x*x + y*y + z*z);
    const shake = Math.abs(mag - 9.8); 

    // 感度調整 (shakeが 5.0 くらいでMAXになるように)
    const normalized = Math.min(shake / 5.0, 1.0);
    
    motionBuffer.push(normalized);
    if(motionBuffer.length > BUFFER_SIZE) motionBuffer.shift();
}

// ==========================================
// 7. 開始処理
// ==========================================
document.getElementById('playBtn').addEventListener('click', async () => {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const state = await DeviceMotionEvent.requestPermission();
        if (state !== 'granted') return alert("センサー許可が必要です");
    }
    
    window.addEventListener('devicemotion', handleMotion);
    await Tone.start();
    
    setupAudio();
    startLoop();
    
    isPlaying = true;
    update();
    
    document.getElementById('playBtn').style.display = 'none';
});
</script>
</body>
</html>