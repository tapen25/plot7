<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Motion Music</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 20px; background: #e0e5ec; color: #555; }
        h1 { color: #7b8fa3; }
        #startBtn { padding: 15px 30px; font-size: 1.2rem; background: #fff; border: none; border-radius: 50px; color: #7b8fa3; cursor: pointer; margin-top: 20px; box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #ffffff; transition: 0.2s;}
        #startBtn:active { box-shadow: inset 6px 6px 12px #b8b9be, inset -6px -6px 12px #ffffff; }
        #status { margin-top: 30px; line-height: 2.0; background: #fff; padding: 20px; border-radius: 20px; box-shadow: 6px 6px 12px #b8b9be, -6px -6px 12px #ffffff; display: inline-block; min-width: 250px;}
        .data { font-weight: bold; font-size: 1.4rem; color: #88aadd; }
        .label { font-size: 0.8rem; color: #aaa; display: block; margin-bottom: -5px;}
        #debug { font-size: 0.8rem; color: #999; margin-top: 20px; }
    </style>
</head>
<body>

    <h1>Soft Motion Music</h1>
    <p>柔らかい音と歩く体験</p>
    <button id="startBtn">Tap to Start</button>
    
    <div id="status">
        <div><span class="label">今の動き (Activity)</span><span id="actVal" class="data">0.00</span></div>
        <div style="margin-top:10px;"><span class="label">物語の進行 (Accumulation)</span><span id="progressVal" class="data">0%</span></div>
        <div style="margin-top:10px;"><span class="label">現在の構成</span><span id="layerText" style="font-size:0.9rem;">ピアノのみ</span></div>
    </div>
    <div id="debug">Sensor: <span id="sensorState">待機中</span></div>

<script>
// ==========================================
// 1. 変数定義
// ==========================================
const BUFFER_SIZE = 30; 
const motionBuffer = []; 
let targetActivity = 0.0; 
let activity = 0.0;       
let accumulatedEnergy = 0.0; // 時間的変化（蓄積値）
let smoothedVariance = 0.0; 

let motionListenerAttached = false;
let isWindPlaying = false;

// ==========================================
// 2. 音楽データ (優しいコード進行)
// ==========================================
// Major7, add9系を多用して浮遊感を出す
const chords = [
  ["C3","G3","B3","E4"], // CMaj7
  ["G2","B2","D3","F#3"], // GMaj7
  ["A2","C3","E3","G3"], // Am7
  ["E2","G2","B2","D3"], // Em7
  ["F2","A2","C3","E3"], // FMaj7
  ["C3","E3","G3","B3"], // CMaj7
  ["D2","F2","A2","C3"], // Dm7
  ["G2","B2","D3","F3"]  // G7
];

const scales = [
    ["C4","D4","E4","G4","B4"], 
    ["G3","B3","D4","F#4","A4"],
    ["A3","C4","E4","G4","B4"], 
    ["E3","G3","B3","D4","F#4"],
    ["F3","A3","C4","E4","G4"], 
    ["C4","E4","G4","B4","D5"], 
    ["D4","F4","A4","C5","E5"], 
    ["G3","B3","D4","F4","A4"] 
];

// ==========================================
// 3. シンセサイザー設定 (柔らかさ重視)
// ==========================================
let chordSynth, melodySynth, bassSynth, kick, shaker, windSynth, sparkleSynth;
let masterReverb, chorus;

function setupSynths() {
    // 全体にかける深いリバーブ
    masterReverb = new Tone.Reverb({ decay: 6, wet: 0.5 }).toDestination();
    
    // コード用: コーラスエフェクトで広がりを出す
    chorus = new Tone.Chorus(4, 2.5, 0.5).connect(masterReverb).start();

    // 【改良】コードシンセ: フィルターを閉じて柔らかく
    chordSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -8,
        oscillator: { type: "fatsine", count: 3, spread: 20 }, // サイン波ベース
        envelope: { attack: 2, decay: 1, sustain: 1, release: 3 } // ふわっと入る
    }).connect(chorus);
    
    // フィルターを追加して高音をカット（こもらせる）
    const chordFilter = new Tone.Filter(600, "lowpass").connect(chorus);
    chordSynth.disconnect();
    chordSynth.connect(chordFilter);


    // 【改良】ベース: 丸い音
    bassSynth = new Tone.MonoSynth({
        volume: -10,
        oscillator: { type: "triangle" }, // 三角波
        filter: { Q: 1, type: "lowpass", rollover: -12, frequency: 200 },
        envelope: { attack: 0.1, decay: 0.5, sustain: 0.8, release: 1 }
    }).connect(masterReverb);

    // メロディ: エレピっぽい音
    melodySynth = new Tone.PolySynth(Tone.Synth, {
        volume: -8,
        oscillator: { type: "triangle" },
        envelope: { attack: 0.05, decay: 0.3, sustain: 0.2, release: 1 }
    }).connect(masterReverb);

    // 環境音: 走った時の風（ホワイトノイズ + フィルタ）
    windSynth = new Tone.NoiseSynth({
        volume: -25,
        noise: { type: "pink" },
        envelope: { attack: 2, decay: 1, sustain: 1, release: 3 }
    });
    const windFilter = new Tone.AutoFilter({ frequency: 0.2, baseFrequency: 300, octaves: 3 }).toDestination().start();
    windSynth.connect(windFilter);

    // キラキラ音
    sparkleSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -15,
        oscillator: { type: "sine" },
        envelope: { attack: 0.01, decay: 0.5, sustain: 0, release: 1 }
    }).connect(masterReverb);

    // リズム: シェイカー（ハイハットより耳に優しい）
    shaker = new Tone.NoiseSynth({ 
        volume: -18, 
        envelope: { attack: 0.01, decay: 0.05, sustain: 0 } 
    }).connect(masterReverb);
    
    // キック: 控えめに
    kick = new Tone.MembraneSynth({ volume: -10 }).toDestination();
}

// ==========================================
// 4. 音楽生成
// ==========================================
function startMusicLoop() {
    Tone.Transport.bpm.value = 90;

    // --- A. コード (基本) ---
    Tone.Transport.scheduleRepeat((time) => {
        const bar = Math.floor(Number(Tone.Transport.position.split(":")[0]) % 8);
        chordSynth.triggerAttackRelease(chords[bar], "1n", time);

        // レイヤー制御: 蓄積エネルギー(accumulatedEnergy)が30を超えたらベース追加
        if (accumulatedEnergy > 30) {
            const root = chords[bar][0].replace("3","2").replace("2","1");
            bassSynth.triggerAttackRelease(root, "1n", time);
        }
    }, "1n");

    // --- B. メロディ ---
    let tick = 0;
    Tone.Transport.scheduleRepeat((time) => {
        const bar = Math.floor(Number(Tone.Transport.position.split(":")[0]) % 8);
        
        // 優しい音なので少し多めに鳴らしても邪魔にならない
        // activityが高いほど動きが出る
        if (tick % 2 === 0) {
            // エネルギーが高いほど確率アップ
            let prob = 0.2 + (accumulatedEnergy / 150); 
            if (activity > 0.5) prob += 0.4;

            if (Math.random() < prob) {
                const note = scales[bar][Math.floor(Math.random() * scales[bar].length)];
                melodySynth.triggerAttackRelease(note, "8n", time);
            }
        }
        tick++;
    }, "8n");

    // --- C. リズム (シェイカー) ---
    Tone.Transport.scheduleRepeat((time) => {
        const s16 = Math.floor(Tone.Transport.ticks / (Tone.Transport.PPQ / 4)) % 16;
        
        // エネルギー50以上でシェイカー
        if (accumulatedEnergy > 50) {
             if (s16 % 4 === 0 || s16 % 4 === 2) shaker.triggerAttackRelease("32n", time);
             if (activity > 0.6 && s16 % 2 !== 0) shaker.triggerAttackRelease("32n", time, 0.5); // 走ると細かくなる
        }

        // エネルギー80以上でキック (心音のような優しさで)
        if (accumulatedEnergy > 80) {
            if (s16 % 4 === 0) kick.triggerAttackRelease("C1", "8n", time);
        }

    }, "16n");

    // --- D. 偶発的キラキラ (休憩中) ---
    setInterval(() => {
        if (activity < 0.2) { 
            // 止まっているとき
            if (Math.random() < 0.4) {
                const note = ["C6","E6","G6","B6"][Math.floor(Math.random()*4)];
                sparkleSynth.triggerAttackRelease(note, "8n");
            }
        }
    }, 1500);

    Tone.Transport.start();
}

// ==========================================
// 5. センサー & ループ
// ==========================================
function handleMotion(event) {
    const a = event.accelerationIncludingGravity;
    if (!a) return;
    const mag = Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
    motionBuffer.push(mag);
    if (motionBuffer.length > BUFFER_SIZE) motionBuffer.shift();

    if (motionBuffer.length < 5) return;
    const mean = motionBuffer.reduce((a,b)=>a+b)/motionBuffer.length;
    const variance = motionBuffer.reduce((a,b)=>a + Math.pow(b-mean, 2),0)/motionBuffer.length;
    const stdDev = Math.sqrt(variance);

    targetActivity = Math.min(stdDev / 4.0, 1.0); // 感度調整
    smoothedVariance = smoothedVariance * 0.9 + stdDev * 0.1;
}

function updateLoop() {
    activity += (targetActivity - activity) * 0.1;

    // --- レイヤー制御ロジック (時間的変化) ---
    // 動いているとエネルギーが溜まる (上限100)
    // これにより「歩き続けると曲が育つ」を実現
    if (activity > 0.2) {
        accumulatedEnergy += 0.08; 
    } else {
        accumulatedEnergy -= 0.05; // 止まると少しずつ戻る
    }
    accumulatedEnergy = Math.max(0, Math.min(100, accumulatedEnergy));

    // --- 音響効果の反映 ---
    
    // 1. 風 (瞬発的なActivityに連動)
    if (activity > 0.8) {
        if (!isWindPlaying) { windSynth.triggerAttack(Tone.now()); isWindPlaying = true; }
        windSynth.volume.rampTo(Tone.gainToDb(activity * 0.4), 0.1);
    } else {
        if (isWindPlaying) { windSynth.triggerRelease(); isWindPlaying = false; }
    }

    // 2. BPM (ゆったり歩くペースに)
    let targetBpm = 90 + (smoothedVariance * 5);
    targetBpm = Math.max(80, Math.min(120, targetBpm));
    Tone.Transport.bpm.rampTo(targetBpm, 0.5);

    // --- 表示 ---
    document.getElementById('actVal').innerText = activity.toFixed(2);
    document.getElementById('progressVal').innerText = Math.floor(accumulatedEnergy) + "%";
    
    // 現在の楽器構成を表示
    let layers = ["ピアノコード"];
    if (accumulatedEnergy > 30) layers.push("ベース");
    if (accumulatedEnergy > 50) layers.push("シェイカー");
    if (accumulatedEnergy > 80) layers.push("キック");
    document.getElementById('layerText').innerText = layers.join(" + ");

    requestAnimationFrame(updateLoop);
}

// ==========================================
// 6. スタート処理
// ==========================================
const btn = document.getElementById('startBtn');
const sensorState = document.getElementById('sensorState');

btn.addEventListener('click', async () => {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
            const permissionState = await DeviceMotionEvent.requestPermission();
            if (permissionState === 'granted') {
                window.addEventListener('devicemotion', handleMotion);
                motionListenerAttached = true;
                sensorState.innerText = "iOS Sensor OK";
            }
        } catch (e) { alert(e); return; }
    } else {
        window.addEventListener('devicemotion', handleMotion);
        motionListenerAttached = true;
        sensorState.innerText = "Android/PC Sensor OK";
    }

    await Tone.start();
    setupSynths();

    if (motionListenerAttached) {
        btn.innerText = "Playing...";
        btn.style.background = "#eef";
        startMusicLoop();
        updateLoop();
    }
});
</script>
</body>
</html>