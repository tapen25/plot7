<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stylish Wind Walk</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { font-family: 'Gill Sans', sans-serif; text-align: center; padding: 20px; background: #0f172a; color: #fff; }
        h1 { color: #38bdf8; font-weight: 200; letter-spacing: 4px; text-transform: uppercase; }
        
        #startBtn { 
            padding: 20px 50px; font-size: 1.1rem; background: transparent; 
            border: 1px solid #38bdf8; border-radius: 0; color: #38bdf8; 
            cursor: pointer; margin-top: 30px; letter-spacing: 2px; transition: 0.3s;
        }
        #startBtn:hover { background: #38bdf8; color: #000; box-shadow: 0 0 20px #38bdf8; }
        
        #status { margin-top: 50px; display: inline-block; width: 80%; max-width: 400px; }
        .bar-container { background: #1e293b; height: 10px; margin: 20px 0; position: relative; width: 100%; }
        .bar { height: 100%; transition: width 0.2s; }
        #windBar { background: linear-gradient(90deg, #38bdf8, #fff); width: 0%; }
        #styleBar { background: linear-gradient(90deg, #a855f7, #ec4899); width: 0%; }
        
        .label { font-size: 0.8rem; color: #94a3b8; display: flex; justify-content: space-between; }
        #styleText { color: #ec4899; font-weight: bold; }
    </style>
</head>
<body>

    <h1>Aero Walk</h1>
    <p>Speed creates Wind. Time creates Style.</p>
    <button id="startBtn">INITIALIZE</button>
    
    <div id="status">
        <div class="label"><span>WIND VELOCITY (Movement)</span></div>
        <div class="bar-container"><div id="windBar" class="bar"></div></div>
        
        <div class="label"><span>STYLE LEVEL (Duration)</span><span id="styleText">Mono</span></div>
        <div class="bar-container"><div id="styleBar" class="bar"></div></div>
    </div>

<script>
// ==========================================
// 1. 変数定義
// ==========================================
const BUFFER_SIZE = 20; 
const motionBuffer = []; 
let activity = 0.0;       // 瞬発値 (風、ドラムON/OFF)
let targetActivity = 0.0;
let styleLevel = 0.0;     // 蓄積値 (ハモり、音色変化)
let smoothedVariance = 0.0; 

// ==========================================
// 2. 音楽理論データ (おしゃれなCマイナー・ドリアン)
// ==========================================
// C Minor 7 / F7 / Eb Maj7 等を想定したスケール
const scale = ["C4","D4","Eb4","F4","G4","A4","Bb4","C5","D5","Eb5"];

// ==========================================
// 3. シンセサイザー (爽快感 & グルーヴ重視)
// ==========================================
let windSynth, windFilter, windPanner;
let bassSynth, drumKit;
let leadSynth;
let delay, reverb;

function setupSynths() {
    // 空間系: 広がりを持たせる
    reverb = new Tone.Reverb({ decay: 3, wet: 0.4 }).toDestination();
    delay = new Tone.PingPongDelay("8n.", 0.2).connect(reverb);

    // --- A. 風の音 (爽快感のコア) ---
    // ピンクノイズをフィルタリングして風を作る
    windSynth = new Tone.Noise("pink").start();
    windFilter = new Tone.Filter({ type: "bandpass", Q: 1 }); 
    windPanner = new Tone.Panner3D({ panningModel: "HRTF" }); // 立体音響
    
    // 接続: Noise -> Filter -> Panner -> Out
    windSynth.connect(windFilter);
    windFilter.connect(windPanner);
    windPanner.toDestination();
    windSynth.volume.value = -99; // 最初は無音

    // --- B. ベース (太く効かせる) ---
    bassSynth = new Tone.MonoSynth({
        volume: -6,
        oscillator: { type: "sawtooth" }, // ソウ波でエッジを効かせる
        filter: { Q: 2, type: "lowpass", rollover: -24, frequency: 400 },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0.4, release: 0.5 }
    }).toDestination();

    // --- C. リード (メロディ & ハモり) ---
    // ポリフォニック(和音)対応
    leadSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -8,
        oscillator: { type: "triangle" }, // 丸いが芯のある音
        envelope: { attack: 0.02, decay: 0.1, sustain: 0.3, release: 1 }
    }).connect(delay);

    // --- D. ドラム (Groovy) ---
    drumKit = {
        kick: new Tone.MembraneSynth({ volume: 0 }).toDestination(), // キック強め
        snare: new Tone.NoiseSynth({ volume: -8, envelope: { decay: 0.2 } }).connect(reverb),
        hihat: new Tone.MetalSynth({ volume: -15, frequency: 200, envelope: { decay: 0.05 }, harmonicity: 5.1 }).connect(reverb),
        openHat: new Tone.MetalSynth({ volume: -15, frequency: 200, envelope: { decay: 0.2 }, harmonicity: 5.1 }).connect(reverb)
    };
}

// ==========================================
// 4. ミュージックループ
// ==========================================
function startMusicLoop() {
    Tone.Transport.bpm.value = 115; // 少し早めのウォーキングテンポ

    // --- 1. ドラム & ベース (グルーヴの土台) ---
    // 歩き始めると即座に鳴る
    Tone.Transport.scheduleRepeat((time) => {
        const s = Math.floor(Tone.Transport.ticks / (Tone.Transport.PPQ / 4)) % 16;
        
        if (activity > 0.2) {
            // Kick (4つ打ち)
            if (s % 4 === 0) drumKit.kick.triggerAttackRelease("C1", "8n", time);
            
            // Bass (裏打ちで疾走感)
            // 0--x 0--x のようなパターン
            if (s % 4 === 2) {
                // ベースラインも少し動かす
                let note = (s < 8) ? "C2" : "F2"; 
                bassSynth.triggerAttackRelease(note, "8n", time);
            }

            // Snare (2,4拍)
            if (s % 8 === 4) drumKit.snare.triggerAttackRelease("8n", time);

            // Hihat (16ビート)
            if (s % 2 !== 0) { // 裏
                if (s % 4 === 2) drumKit.openHat.triggerAttackRelease("32n", time); // オープン
                else drumKit.hihat.triggerAttackRelease("32n", time); // クローズ
            }
        }
    }, "16n");

    // --- 2. メロディ (レイヤー制御でおしゃれに進化) ---
    let tick = 0;
    Tone.Transport.scheduleRepeat((time) => {
        // 歩いているときだけメロディ生成
        if (activity > 0.25 && tick % 4 === 0) { // 8分音符単位
            
            // 確率で鳴らす (ランダム感)
            if (Math.random() < 0.6) {
                // 音を選ぶ
                const index = Math.floor(Math.random() * (scale.length - 2)); // 範囲外エラー防止
                const rootNote = scale[index];
                
                // === ここがレイヤー制御のキモ ===
                // styleLevel (蓄積値 0-100) に応じて和音を積む
                const notesToPlay = [rootNote];

                // Lv2 (30%~): ハモり追加 (3度上 or 4度上) -> おしゃれ感
                if (styleLevel > 30) {
                    const harmonyNote = scale[index + 2]; // 2つ隣の音(3度/4度)
                    notesToPlay.push(harmonyNote);
                }

                // Lv3 (70%~): オクターブ上のキラキラ装飾 -> 高揚感
                if (styleLevel > 70) {
                    if (Math.random() < 0.5) {
                        const sparkleNote = scale[index + 4]; // 5度〜7度上
                        // 1オクターブ上げる処理簡易版
                        // Tone.Frequency(sparkleNote).transpose(12) 的な処理の代用
                        // ここではスケールの高音域を使用
                        notesToPlay.push(scale[Math.min(index + 5, scale.length - 1)]);
                    }
                }

                leadSynth.triggerAttackRelease(notesToPlay, "8n", time);
            }
        }
        tick++;
    }, "16n");

    Tone.Transport.start();
}

// ==========================================
// 5. センサー処理 & フィードバック
// ==========================================
function handleMotion(event) {
    const a = event.accelerationIncludingGravity;
    if (!a) return;
    const mag = Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
    
    motionBuffer.push(mag);
    if (motionBuffer.length > BUFFER_SIZE) motionBuffer.shift();

    if (motionBuffer.length < 5) return;
    
    const mean = motionBuffer.reduce((a,b)=>a+b)/motionBuffer.length;
    const stdDev = Math.sqrt(motionBuffer.reduce((a,b)=>a + Math.pow(b-mean, 2),0)/motionBuffer.length);

    targetActivity = Math.min(stdDev / 4.0, 1.0); 
    smoothedVariance = smoothedVariance * 0.9 + stdDev * 0.1;
}

function updateLoop() {
    // 1. Activity (瞬発力) のスムーズ化
    activity += (targetActivity - activity) * 0.1;

    // 2. 風のエフェクト制御 (Activityに直結)
    if (activity > 0.1) {
        // 音量: 動けば鳴る
        let vol = -40 + (activity * 30); // Max -10dB
        windSynth.volume.rampTo(vol, 0.1);
        
        // フィルター: 速いほど高音成分が通り、「シュッ」という音になる
        // 200Hz(こもる) -> 3000Hz(鋭い風切り音)
        let freq = 200 + (activity * 2800);
        windFilter.frequency.rampTo(freq, 0.1);
    } else {
        windSynth.volume.rampTo(-99, 0.5);
    }

    // 3. スタイルレベル (蓄積値) の制御
    // 歩いていると「おしゃれ度」が溜まる
    if (activity > 0.3) {
        styleLevel += 0.1; 
    } else {
        styleLevel -= 0.05; // 止まると徐々に単音に戻る
    }
    styleLevel = Math.max(0, Math.min(100, styleLevel));

    // 4. BPM制御 (歩行同期)
    let targetBpm = 110 + (smoothedVariance * 5);
    targetBpm = Math.max(100, Math.min(130, targetBpm));
    Tone.Transport.bpm.rampTo(targetBpm, 0.5);

    // --- UI更新 ---
    document.getElementById('windBar').style.width = (activity * 100) + "%";
    document.getElementById('styleBar').style.width = styleLevel + "%";
    
    const txt = document.getElementById('styleText');
    if (styleLevel < 30) txt.innerText = "Mono (Simple)";
    else if (styleLevel < 70) txt.innerText = "Harmony (Stylish)";
    else txt.innerText = "Ensemble (Sparkle!)";

    requestAnimationFrame(updateLoop);
}

// ==========================================
// 6. 開始処理
// ==========================================
const btn = document.getElementById('startBtn');

btn.addEventListener('click', async () => {
    // iOS Permission
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        try {
            const p = await DeviceMotionEvent.requestPermission();
            if (p !== 'granted') return alert("センサー許可が必要です");
        } catch (e) { return alert(e); }
    }
    window.addEventListener('devicemotion', handleMotion);

    await Tone.start();
    setupSynths();

    btn.innerText = "WALKING MODE ON";
    btn.style.opacity = 0.5;
    startMusicLoop();
    updateLoop();
});
</script>
</body>
</html>