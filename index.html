<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Motion BPM → AB Loop Synth</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<style>
  body {
    font-family: sans-serif;
    text-align: center;
    padding: 20px;
    background: #f0f0f0;
  }
  button {
    font-size: 1.2rem;
    padding: 14px 32px;
  }
  #status, #debug {
    margin-top: 12px;
    font-size: 1rem;
  }
</style>
</head>

<body>

<button id="start">Start（iOSは要タップ）</button>
<div id="status">停止中</div>
<div id="debug">BPM: 0</div>

<script>
// =================================================
// グローバル状態
// =================================================
let isPlaying = false;
let currentNoteIndex = 0;
let usePatternA = true;
let smoothedBPM = 80;

// モーション履歴（2秒）
let motionHistory = [];
const HISTORY_DURATION = 2000;

// =================================================
// パターン定義
// =================================================
const patterns = {
  A: ["D4","C4","B3","D4","C4","A3","G3","A3","B3"],
  B: ["D4","C4","B3","D4","C4","A3","G3","B3","G3"]
};

const durations = [0.25,0.25,0.25,0.25,0.5,0.5,0.5,0.5,1.0];

// =================================================
// BPM → Synth 切替
// =================================================
let currentSynth = null;
let currentSynthType = null;

function getSynthByBPM(bpm) {
  let type;
  if (bpm >= 100 && bpm < 110) type = "soft";
  else if (bpm < 120) type = "fm";
  else type = "mono";

  if (currentSynth && currentSynthType === type) return currentSynth;

  if (currentSynth) currentSynth.dispose();

  if (type === "soft") {
    currentSynth = new Tone.PolySynth(Tone.Synth, {
      volume: 0,
      oscillator: { type: "triangle" },
      envelope: { attack: 0.005, decay: 0.1, sustain: 0.3, release: 1 }
    }).toDestination();
  }

  if (type === "fm") {
    currentSynth = new Tone.FMSynth({
      volume: 0,
      harmonicity: 3,
      modulationIndex: 12.22,
      envelope: { attack: 0.01, decay: 0.2, sustain: 1, release: 0.5 },
      modulation: { type: "square" },
      modulationEnvelope: { attack: 0.2, decay: 0.01, sustain: 1, release: 0.5 }
    }).toDestination();
  }

  if (type === "mono") {
    currentSynth = new Tone.PolySynth(Tone.MonoSynth, {
      volume: -8,
      oscillator: { type: "square8" },
      filter: { type: "lowpass", rolloff: -12, Q: 1 },
      envelope: { attack: 0.05, decay: 0.3, sustain: 0.4, release: 0.8 },
      filterEnvelope: {
        attack: 0.001, decay: 0.7, sustain: 0.1, release: 0.8,
        baseFrequency: 300, octaves: 4
      }
    }).toDestination();
  }

  currentSynthType = type;
  return currentSynth;
}

// =================================================
// モーションセンサー → BPM
// =================================================
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;

  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({ time: now, val: mag });
  motionHistory = motionHistory.filter(d => now - d.time < HISTORY_DURATION);

  const avg =
    motionHistory.reduce((s, d) => s + d.val, 0) /
    (motionHistory.length || 1);

  smoothedBPM = mapAccelToBPM(avg);

  document.getElementById("debug").innerText =
    `BPM: ${Math.floor(smoothedBPM)}`;

  // 強く振ったら再生開始
  if (!isPlaying && mag > 15) {
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let bpm = 100 + (a - 10) * 8;
  return Math.max(60, Math.min(200, bpm));
}

// =================================================
// シーケンス（ABループ）
// =================================================
function startSequence() {
  isPlaying = true;
  currentNoteIndex = 0;
  playNextNote();
}

function playNextNote() {
  if (!isPlaying) return;

  const pattern = usePatternA ? patterns.A : patterns.B;

  if (currentNoteIndex >= pattern.length) {
    usePatternA = !usePatternA;   // ★ AB切替
    currentNoteIndex = 0;
  }

  const note = pattern[currentNoteIndex];
  const dur = durations[currentNoteIndex];
  const beat = 60 / smoothedBPM;
  const timeLen = beat * dur;

  const synth = getSynthByBPM(smoothedBPM);
  synth.triggerAttackRelease(note, timeLen * 0.9, Tone.now());

  document.getElementById("status").innerText =
    `再生中: ${usePatternA ? "A" : "B"} ${currentNoteIndex + 1}`;

  currentNoteIndex++;
  setTimeout(playNextNote, timeLen * 1000);
}

// =================================================
// Start ボタン（最重要）
// =================================================
document.getElementById("start").onclick = async () => {
  // 音を有効化
  await Tone.start();
  console.log("Tone started");

  // iOS センサー許可
  if (typeof DeviceMotionEvent?.requestPermission === "function") {
    const res = await DeviceMotionEvent.requestPermission();
    if (res !== "granted") {
      alert("モーションセンサーが許可されていません");
      return;
    }
  }

  // センサー取得開始（★ BPM算出より前）
  window.addEventListener("devicemotion", handleMotion);

  document.getElementById("status").innerText = "センサー待機中...";
};
</script>

</body>
</html>
