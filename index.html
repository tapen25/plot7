<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Theory-Based Motion Music</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { font-family: sans-serif; background: #222; color: #fff; text-align: center; padding: 20px; }
        #startBtn { padding: 20px 40px; font-size: 1.2rem; background: #e91e63; border: none; color: #fff; border-radius: 8px; cursor: pointer; margin-top: 50px; }
        #status { margin-top: 30px; font-size: 1.2rem; line-height: 1.8; }
        .label { font-size: 0.8rem; color: #aaa; }
        .val { font-weight: bold; color: #e91e63; margin-right: 15px; }
    </style>
</head>
<body>

    <h1>Interactive Motion Music</h1>
    <p>理論適用版：<br>1. 振る瞬間に音が鳴る (Playful)<br>2. 徐々に盛り上がる (Emotional)<br>3. 傾きで雰囲気が変わる (Aleatoric)</p>
    <button id="startBtn">TAP TO START</button>
    
    <div id="status">
        <div><span class="label">Intensity (Smooth):</span> <span id="actVal" class="val">0.00</span></div>
        <div><span class="label">Tilt (Mood):</span> <span id="tiltVal" class="val">Flat</span></div>
        <div style="margin-top:20px; font-size: 0.9rem; color:#888;">
            強く振るとステップ音(Playful)<br>
            傾けるとスケール変化(Aleatoric)
        </div>
    </div>

<script>
// ==========================================
// 1. 変数定義
// ==========================================
let activity = 0.0;       // スムーズな活動量 (0.0 - 1.0)
let targetActivity = 0.0; 
let tiltY = 0.0;          // スマホの縦の傾き (Gravity Y)

// ステップ検出用 (Playful)
let lastMag = 0;
let stepCooldown = 0;

// データバッファ (Activity計算用)
const motionBuffer = [];
const DURATION = 1500; 

// ==========================================
// 2. 音響設計 (Vertical Layering)
// ==========================================
let chordSynth, stepSynth, arpSynth;
let drumLow, drumHigh;
let gainLow, gainHigh, gainArp; // ボリューム制御用ノード

// スケール定義 (Aleatoric: 傾きで切り替え)
const scaleMajor = ["C4", "D4", "E4", "G4", "A4"];
const scaleMinor = ["C4", "Eb4", "F4", "G4", "Bb4"];
let currentScale = scaleMajor;

async function setupSynths() {
    // --- A. 映画的 (Emotional): レイヤー構造 ---
    // ドラムを2つのレイヤーに分け、Gainノードで音量管理する
    gainLow = new Tone.Gain(0).toDestination();
    gainHigh = new Tone.Gain(0).toDestination();
    gainArp = new Tone.Gain(0).toDestination();

    // 低エネルギー用ドラム (Kick, Simle Hat)
    drumLow = new Tone.MembraneSynth({ volume: -6 }).connect(gainLow);
    
    // 高エネルギー用ドラム (Snare, Noise)
    drumHigh = new Tone.NoiseSynth({ volume: -12 }).connect(gainHigh);

    // アルペジオ (活動量で音量が上がる)
    arpSynth = new Tone.Synth({
        oscillator: { type: "sine" },
        envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 1 }
    }).connect(gainArp);

    // --- B. 遊び的 (Playful): 1:1の反応 ---
    // ステップ/アクション用シンセ (直接Destinationへ)
    stepSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -8,
        oscillator: { type: "triangle" },
        envelope: { attack: 0.01, decay: 0.2, sustain: 0.0, release: 0.2 }
    }).toDestination();
    
    // --- C. ベースのコード (環境音的) ---
    chordSynth = new Tone.PolySynth(Tone.Synth, {
        volume: -15,
        oscillator: { type: "fatsawtooth" },
        envelope: { attack: 1, decay: 1, sustain: 1, release: 2 }
    }).toDestination();
}

// ==========================================
// 3. ループ処理
// ==========================================
function startMusicLoop() {
    Tone.Transport.bpm.value = 100;

    // --- ドラムループ (常に回っているが音量が変化する) ---
    const loop = new Tone.Loop((time) => {
        // 16分音符のカウント
        const s = Math.floor(Tone.Transport.ticks / (Tone.Transport.PPQ / 4)) % 16;

        // Low Layer: 4つ打ちキック (心臓の鼓動的な役割)
        if (s % 4 === 0) drumLow.triggerAttackRelease("C1", "8n", time);

        // High Layer: 裏打ちハイハット & スネア (テンション)
        if (s % 2 !== 0) drumHigh.triggerAttackRelease("32n", time); // Hihat
        if (s % 8 === 4) drumHigh.triggerAttackRelease("16n", time); // Snare like noise
    }, "16n").start(0);

    // --- アルペジオ (背景) ---
    Tone.Transport.scheduleRepeat((time) => {
        // 現在の傾きに応じたスケールからランダム選出
        const note = currentScale[Math.floor(Math.random() * currentScale.length)];
        arpSynth.triggerAttackRelease(note, "16n", time);
    }, "8n");

    // --- アンビエントコード (長周期) ---
    Tone.Transport.scheduleRepeat((time) => {
        // 傾き(Tilt)でルート音を変える (C3 か A2)
        const root = (tiltY > 5) ? "A2" : "C3"; 
        // 構成音は適当に積み上げ
        chordSynth.triggerAttackRelease([root, Tone.Frequency(root).transpose(7)], "2n", time);
    }, "1m");

    Tone.Transport.start();
}

// ==========================================
// 4. センサー処理と理論の実装
// ==========================================
function handleMotion(event) {
    if (!event.accelerationIncludingGravity) return;

    const acc = event.accelerationIncludingGravity;
    // 重力込みのベクトル長
    const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
    
    // Tilt (傾き) 検知: Y軸の重力成分を見る
    // スマホを立てると y は -9.8 や 9.8 に近づく
    // ここでは簡易的に絶対値を使用
    tiltY = Math.abs(acc.y); 

    // --- Playful: ステップ検出 (ピーク検出) ---
    // 「前回より大きく」かつ「閾値(13くらい)を超えた」瞬間
    if (mag > 13 && mag > lastMag && stepCooldown <= 0) {
        onStepDetected(); // ★ここが遊び的インタラクションの核
        stepCooldown = 10; // 連打防止
    }
    lastMag = mag;
    if (stepCooldown > 0) stepCooldown--;

    // --- Activity計算 (標準偏差ロジックは維持) ---
    const now = Date.now();
    motionBuffer.push({ t: now, m: mag });
    while (motionBuffer.length > 0 && motionBuffer[0].t < now - DURATION) {
        motionBuffer.shift();
    }
    
    if (motionBuffer.length > 5) {
        const vals = motionBuffer.map(d => d.m);
        const mean = vals.reduce((a,b)=>a+b,0)/vals.length;
        const variance = vals.reduce((a,b)=>a+(b-mean)**2,0)/vals.length;
        const std = Math.sqrt(variance);
        // 正規化 (0.0 - 1.0)
        targetActivity = Math.min(std / 5.0, 1.0);
    }
}

// ★ Playful: ユーザーのアクションに即座に反応する音
function onStepDetected() {
    // コード進行に合った音を「ポン」と鳴らす
    // ここではランダムに和音を鳴らす
    const notes = [
        currentScale[0], 
        currentScale[2], 
        Tone.Frequency(currentScale[0]).transpose(12)
    ];
    stepSynth.triggerAttackRelease(notes, "8n");
    
    // 視覚的フィードバック（背景が一瞬光るなどすると尚良い）
    document.body.style.backgroundColor = "#333";
    setTimeout(() => document.body.style.backgroundColor = "#222", 100);
}

// ==========================================
// 5. 更新ループ (Emotional & Aleatoricの適用)
// ==========================================
function updateLoop() {
    // Activityのスムージング
    activity += (targetActivity - activity) * 0.1;

    // --- Emotional: インテンシティによる「縦の遷移」 ---
    // activityに応じて各楽器のボリュームを連続的に変化させる
    // Low Drum: 常に少し鳴っているが、動くとフルになる
    gainLow.gain.rampTo(0.2 + activity * 0.8, 0.1);
    
    // High Drum: 安静時は無音(0)、激しくなると聞こえてくる
    // 閾値ではなく、0.3を超えたあたりからリニアに音量が上がる
    const highVol = Math.max(0, (activity - 0.3) * 1.5); 
    gainHigh.gain.rampTo(Math.min(highVol, 0.8), 0.1);

    // Arpeggio: 激しいときはうるさいので少し下げる、などの演出も可能
    gainArp.gain.rampTo(0.3 + activity * 0.2, 0.1);

    // BPMも少し変化させる (心拍数変動の模倣)
    const targetBpm = 90 + (activity * 30);
    Tone.Transport.bpm.rampTo(targetBpm, 0.5);

    // --- Aleatoric: 傾きによるムード変化 ---
    // スマホを立てている(Y > 6)ならMinor、寝かせているならMajor
    if (tiltY > 6) {
        currentScale = scaleMinor;
        document.getElementById('tiltVal').innerText = "Active/Vertical (Minor)";
        document.getElementById('tiltVal').style.color = "#00bcd4";
    } else {
        currentScale = scaleMajor;
        document.getElementById('tiltVal').innerText = "Relax/Horizontal (Major)";
        document.getElementById('tiltVal').style.color = "#e91e63";
    }

    // 数値表示
    document.getElementById('actVal').innerText = activity.toFixed(2);

    requestAnimationFrame(updateLoop);
}

// ==========================================
// 6. 初期化 (iOS対応含む)
// ==========================================
const btn = document.getElementById('startBtn');
btn.addEventListener('click', async () => {
    if (typeof DeviceMotionEvent.requestPermission === 'function') {
        const p = await DeviceMotionEvent.requestPermission();
        if (p !== 'granted') return alert("センサー許可が必要です");
    }
    
    window.addEventListener('devicemotion', handleMotion);
    await Tone.start();
    setupSynths().then(() => {
        startMusicLoop();
        updateLoop();
        btn.innerText = "Running...";
        btn.disabled = true;
    });
});
</script>
</body>
</html>