<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Walking Agency – BPM Synth Switch</title>

<script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>

<style>
  body {
    font-family: sans-serif;
    padding: 20px;
    text-align: center;
    background: #f0f0f0;
  }
  button {
    font-size: 1.2rem;
    padding: 15px 30px;
    border-radius: 8px;
    border: none;
    background: #007AFF;
    color: white;
    cursor: pointer;
  }
  #status {
    margin-top: 20px;
    font-weight: bold;
    font-size: 1.2rem;
  }
  #debug {
    margin-top: 10px;
    font-family: monospace;
    color: #444;
  }
</style>
</head>

<body>

<button id="start">Start（iOSは要タップ）</button>
<div id="status">停止中</div>
<div id="debug">BPM: -- / Synth: --</div>

<script>
// =================================================
// グローバル
// =================================================
let isPlaying = false;
let smoothedBPM = 60;

let motionHistory = [];
const HISTORY_DURATION = 4000;

let synth = null;
let currentSynthType = null;

// 小節スケジューリング
let nextBarTime = 0;
let usePatternA = true;

// =================================================
// メロディ
// =================================================
const patterns = {
  A: ["D4","C4","B3","D4","C4","A3","G3","A3","B3"],
  B: ["D4","C4","B3","D4","C4","A3","G3","B3","G3"]
};

const durations = [0.25,0.25,0.25,0.25,0.5,0.5,0.5,0.5,1.0];

// =================================================
// iOS 対策 & 開始
// =================================================
document.getElementById("start").addEventListener("click", async () => {
  await Tone.start();

  if (
    typeof DeviceMotionEvent !== "undefined" &&
    typeof DeviceMotionEvent.requestPermission === "function"
  ) {
    const res = await DeviceMotionEvent.requestPermission();
    if (res !== "granted") {
      alert("モーションセンサーの許可が必要です");
      return;
    }
  }

  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "歩行待機中...";
  document.getElementById("start").style.display = "none";
});

// =================================================
// 加速度 → BPM
// =================================================
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity;
  if (!acc) return;

  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({ time: now, val: mag });

  while (motionHistory.length && now - motionHistory[0].time > HISTORY_DURATION) {
    motionHistory.shift();
  }

  const avg = motionHistory.reduce((s,i)=>s+i.val,0) / motionHistory.length;
  smoothedBPM = mapAccelToBPM(avg);

  const synthType = getSynthTypeByBPM(smoothedBPM);
  document.getElementById("debug").innerText =
    `BPM: ${Math.floor(smoothedBPM)} / Synth: ${synthType}`;

  if (!isPlaying && mag > 13) {
    startSequence();
  }
}

function mapAccelToBPM(a) {
  let v = a - 9.8;
  if (v < 0) v = 0;
  let bpm = 60 + v * 15;
  return Math.min(Math.max(bpm, 60), 180);
}

// =================================================
// BPM → Synth 種別
// =================================================
function getSynthTypeByBPM(bpm) {
  if (bpm >= 100 && bpm < 110) return "soft";
  if (bpm >= 110 && bpm < 120) return "fm";
  if (bpm >= 120) return "mono";
  return "soft";
}

// =================================================
// Synth 生成
// =================================================
function createSynth(type) {
  if (synth) synth.dispose();

  if (type === "soft") {
    synth = new Tone.PolySynth(Tone.Synth, {
      volume: 0,
      oscillator: { type: "triangle" },
      envelope: {
        attack: 0.005,
        decay: 0.1,
        sustain: 0.3,
        release: 1
      }
    }).toDestination();
  }

  if (type === "fm") {
    synth = new Tone.FMSynth({
      volume: 0,
      harmonicity: 3,
      modulationIndex: 12.22,
      envelope: {
        attack: 0.01,
        decay: 0.2,
        sustain: 1,
        release: 0.5
      },
      modulation: { type: "square" },
      modulationEnvelope: {
        attack: 0.2,
        decay: 0.01,
        sustain: 1,
        release: 0.5
      }
    }).toDestination();
  }

  if (type === "mono") {
    synth = new Tone.PolySynth(Tone.MonoSynth, {
      volume: -8,
      oscillator: { type: "square8" },
      filter: {
        type: "lowpass",
        rolloff: -12,
        Q: 1
      },
      envelope: {
        attack: 0.05,
        decay: 0.3,
        sustain: 0.4,
        release: 0.8
      },
      filterEnvelope: {
        attack: 0.001,
        decay: 0.7,
        sustain: 0.1,
        release: 0.8,
        baseFrequency: 300,
        octaves: 4
      }
    }).toDestination();
  }

  currentSynthType = type;
}

// =================================================
// シーケンス
// =================================================
function startSequence() {
  isPlaying = true;
  nextBarTime = Tone.now() + 0.1;
  document.getElementById("status").innerText = "再生中";
}

function scheduleBar() {
  const bpm = smoothedBPM;
  const synthType = getSynthTypeByBPM(bpm);

  if (synthType !== currentSynthType) {
    createSynth(synthType);
  }

  const pattern = usePatternA ? patterns.A : patterns.B;
  const beatDur = 60 / bpm;

  let t = nextBarTime;

  for (let i = 0; i < pattern.length; i++) {
    const dur = durations[i] * beatDur;
    synth.triggerAttackRelease(pattern[i], dur, t);
    t += dur;
  }

  const totalBeats = durations.reduce((a,b)=>a+b,0);
  nextBarTime += totalBeats * beatDur;

  usePatternA = !usePatternA;
}

// =================================================
// 先読みループ
// =================================================
setInterval(() => {
  if (!isPlaying) return;
  if (nextBarTime - Tone.now() < 0.1) {
    scheduleBar();
  }
}, 25);
</script>

</body>
</html>
