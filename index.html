<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motion Generative Music V2</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <style>
        body { font-family: sans-serif; text-align: center; padding: 20px; background: #222; color: #fff; }
        #startBtn { padding: 15px 30px; font-size: 1.2rem; background: #00d2ff; border: none; border-radius: 50px; color: #000; cursor: pointer; margin-top: 20px; }
        .data { font-weight: bold; font-size: 1.5rem; color: #00d2ff; }
        #visualFeedback { margin-top: 10px; }
    </style>
</head>
<body>

<h1>Motion Music V2</h1>
<p>歩くと音楽が成長し、<br>走ると風が吹きます。</p>

<button id="startBtn">開始 (Tap to Start)</button>

<div id="status">
    <div>Motion Energy: <span id="actVal" class="data">0.00</span></div>
    <div>Story Progress: <span id="progressVal" class="data">0%</span></div>
    <div>BPM: <span id="bpmVal" class="data">100</span></div>
    <div id="visualFeedback">待機中...</div>
</div>

<div id="debug" style="color:#aaa;margin-top:20px;">
    Sensor: <span id="sensorState">待機中</span>
</div>

<script>
// ============================================================
// 1. 変数
// ============================================================
const BUFFER_SIZE = 30;
const motionBuffer = [];
let targetActivity = 0;
let activity = 0;
let accumulatedEnergy = 0;
let smoothedVariance = 0;

let motionListenerAttached = false;
let isWindPlaying = false;

// ============================================================
// 2. コード・スケール
// ============================================================
const chords = [
  ["C3","E3","G3"],
  ["B2","D3","G3"],
  ["A2","C3","E3"],
  ["G2","B2","E3"],
  ["F2","A2","C3"],
  ["E2","G2","C3"],
  ["F2","A2","C3"],
  ["G2","B2","D3"]
];

// ペンタ主体
const scales = [
  ["C4","D4","E4","G4","A4"],
  ["G3","A3","B3","D4","E4"],
  ["A3","C4","E4","G4","A4"],
  ["E3","G3","B3","D4","E4"],
  ["F3","G3","A3","C4","D4"],
  ["C4","D4","E4","G4","A4"],
  ["F3","G3","A3","C4","D4"],
  ["G3","A3","B3","D4","F#4"]
];

// ============================================================
// 3. シンセ定義
// ============================================================
let chordSynth, bassSynth, melodySynth;
let kick, snare, hihat;
let windSynth;
let ambientPads;

// エフェクト
let reverb, delay;

function setupSynths() {

    reverb = new Tone.Reverb({ decay: 6, wet: 0.55 }).toDestination();
    delay  = new Tone.FeedbackDelay("8n", 0.3).connect(reverb);

    // --- コード ---
    chordSynth = new Tone.PolySynth(Tone.Synth, {
      volume: -10,
      oscillator: { type: "sine" },
      envelope: { attack: 1.2, decay: 1.5, sustain: 0.9, release: 3 }
    }).connect(reverb);

    // --- ベース ---
    bassSynth = new Tone.MonoSynth({
      volume: -12,
      oscillator: { type: "sine" },
      filter: { type: "lowpass", frequency: 200, Q: 1 },
      envelope: { attack: 0.1, decay: 0.5, sustain: 0.6, release: 1.2 }
    }).connect(reverb);

    // --- メロディ ---
    melodySynth = new Tone.AMSynth({
      volume: -6,   // 聞こえるように調整
      harmonicity: 2,
      oscillator: { type: "sine" },
      envelope: { attack: 0.02, decay: 0.25, sustain: 0.5, release: 0.8 }
    }).connect(delay);

    // --- ドラム ---
    kick  = new Tone.MembraneSynth({ volume: -4 }).toDestination();
    snare = new Tone.NoiseSynth({ volume: -15, envelope: { decay: 0.2 } }).connect(reverb);
    hihat = new Tone.MetalSynth({ volume: -20, frequency: 200, envelope: { decay: 0.05 } }).toDestination();

    // --- 風 ---
    windSynth = new Tone.NoiseSynth({
        volume: -20,
        noise: { type: "pink" },
        envelope: { attack: 1, decay: 0.5, sustain: 1, release: 2 }
    });
    windSynth.connect(new Tone.Filter(500, "highpass").toDestination());

    // --- アンビエント音群 ---
    ambientPads = [
        new Tone.FMSynth({
            volume: -15,
            harmonicity: 1.5,
            modulationIndex: 2,
            oscillator: { type: "sine" },
            envelope: { attack: 0.6, decay: 2.5, sustain: 0.2, release: 3 }
        }).connect(reverb),

        new Tone.MetalSynth({
            volume: -20,
            frequency: 440,
            harmonicity: 7,
            modulationIndex: 20,
            resonance: 300,
            envelope: { attack: 0.01, decay: 2, release: 1 }
        }).connect(reverb),

        new Tone.NoiseSynth({
            volume: -25,
            noise: { type: "white" },
            envelope: { attack: 0.02, decay: 1.5, sustain: 0, release: 1.5 }
        }).connect(new Tone.AutoFilter({ frequency: 0.2, baseFrequency: 600, octaves: 3 }).toDestination().start())
    ];
}

// ランダムアンビエント
function playAmbientRandom() {
    const choice = ambientPads[Math.floor(Math.random() * ambientPads.length)];
    const notes = ["C5","E5","G5","B5"];
    const n = notes[Math.floor(Math.random()*notes.length)];
    choice.triggerAttackRelease(n, "2n");
}

// ============================================================
// 4. 音楽ループ
// ============================================================
function startMusicLoop() {
    Tone.Transport.bpm.value = 100;

    // --- A: コード ---
    Tone.Transport.scheduleRepeat((time) => {
        const bar = Math.floor(Number(Tone.Transport.position.split(":")[0]) % 8);

        chordSynth.triggerAttackRelease(chords[bar], "1n", time);

        if (accumulatedEnergy > 30) {
            const root = chords[bar][0];
            const bass = Tone.Frequency(root).transpose(-12).toNote(); // -12 semitone
            bassSynth.triggerAttackRelease(bass, "2n", time);
        }
    }, "1n");

    // --- B: メロディ ---
    let tick = 0;
    Tone.Transport.scheduleRepeat((time) => {
        const bar = Math.floor(Number(Tone.Transport.position.split(":")[0]) % 8);
        let division = activity > 0.6 ? 2 : 4;

        if (tick % division === 0) {
            let prob = 0.3 + accumulatedEnergy / 200;
            if (activity > 0.7) prob = 0.9;

            if (Math.random() < prob) {
                const scale = scales[bar];
                const note = scale[Math.floor(Math.random()*scale.length)];
                melodySynth.triggerAttackRelease(note, "8n", time);
            }
        }
        tick++;
    }, "16n");

    // --- C: ドラム ---
    Tone.Transport.scheduleRepeat((time) => {
        const s = Math.floor(Tone.Transport.ticks / (Tone.Transport.PPQ/4)) % 16;

        if (s % 4 === 0) kick.triggerAttackRelease("C1","8n",time);
        if (accumulatedEnergy > 50 && s % 2 === 0) hihat.triggerAttackRelease("32n",time);
        if (activity > 0.5 && s % 8 === 4) snare.triggerAttackRelease("8n",time);

    }, "16n");

    // --- D: アイドリング演出 ---
    setInterval(() => {
        if (activity < 0.2 && accumulatedEnergy < 90) {
            if (Math.random() < 0.3) playAmbientRandom();
        }
    }, 2000);

    Tone.Transport.start();
}

// ============================================================
// 5. センサー
// ============================================================
function handleMotion(event) {
    const a = event.accelerationIncludingGravity;
    if (!a) return;

    const mag = Math.sqrt(a.x*a.x + a.y*a.y + a.z*a.z);
    motionBuffer.push(mag);
    if (motionBuffer.length > BUFFER_SIZE) motionBuffer.shift();

    if (motionBuffer.length < 5) return;

    const mean = motionBuffer.reduce((a,b)=>a+b) / motionBuffer.length;
    const variance = motionBuffer.reduce((a,b)=>a + (b-mean)**2, 0)/motionBuffer.length;
    const stdDev = Math.sqrt(variance);

    targetActivity = Math.min(stdDev / 5.0, 1.0);

    smoothedVariance = smoothedVariance * 0.9 + stdDev * 0.1;
}

// ============================================================
// 6. UI + 風 + BPM
// ============================================================
function updateLoop() {
    activity += (targetActivity - activity) * 0.1;

    if (activity > 0.3) accumulatedEnergy += 0.05;
    else accumulatedEnergy -= 0.02;
    accumulatedEnergy = Math.max(0, Math.min(100, accumulatedEnergy));

    // 風
    if (activity > 0.6) {
        if (!isWindPlaying) {
            windSynth.triggerAttack();
            isWindPlaying = true;
        }
        windSynth.volume.rampTo(-20 + activity * 20, 0.1);
    } else if (isWindPlaying) {
        windSynth.triggerRelease();
        isWindPlaying = false;
    }

    // BPM 90〜140
    let targetBpm = 100 + smoothedVariance * 8;
    targetBpm = Math.max(90, Math.min(140, targetBpm));
    Tone.Transport.bpm.rampTo(targetBpm, 0.5);

    // 画面表示
    document.getElementById("actVal").textContent = activity.toFixed(2);
    document.getElementById("progressVal").textContent = Math.floor(accumulatedEnergy);
    document.getElementById("bpmVal").textContent = Math.round(Tone.Transport.bpm.value);

    const fb = document.getElementById("visualFeedback");
    if (activity < 0.2) fb.textContent = "休憩中...（偶発的アンビエント）";
    else if (activity < 0.6) fb.textContent = "歩行中（物語の進行）";
    else fb.textContent = "走行中！風が吹いている";

    requestAnimationFrame(updateLoop);
}

// ============================================================
// 7. 開始ボタン
// ============================================================
document.getElementById("startBtn").addEventListener("click", async () => {

    // iOS
    if (typeof DeviceMotionEvent.requestPermission === "function") {
        const res = await DeviceMotionEvent.requestPermission();
        if (res === "granted") {
            window.addEventListener("devicemotion", handleMotion);
            motionListenerAttached = true;
            document.getElementById("sensorState").textContent = "センサー取得中（iOS）";
        } else {
            alert("センサーが許可されませんでした");
            return;
        }
    } else {
        window.addEventListener("devicemotion", handleMotion);
        motionListenerAttached = true;
        document.getElementById("sensorState").textContent = "センサー取得中（Android/PC）";
    }

    await Tone.start();
    setupSynths();

    document.getElementById("startBtn").disabled = true;
    document.getElementById("startBtn").textContent = "演奏中...";

    startMusicLoop();
    updateLoop();
});

</script>
</body>
</html>
