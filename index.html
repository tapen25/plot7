// ...existing code...
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Walking Agency Filter Test</title>
<style>
  body { font-family: sans-serif; padding: 20px; text-align: center; background: #f0f0f0; }
  button { font-size: 1.2rem; padding: 15px 30px; border-radius: 8px; border: none; background: #007AFF; color: white; cursor: pointer; }
  #status { margin-top: 20px; font-weight: bold; font-size: 1.2rem; }
  #debug { margin-top: 10px; color: #555; font-family: monospace; }
  #params { margin-top: 10px; font-size: 0.9rem; color: #333; }
</style>
</head>
<body>

<button id="start">Start (iOSã¯è¦ã‚¿ãƒƒãƒ—)</button>
<div id="status">åœæ­¢ä¸­</div>
<div id="debug">BPM: 0</div>
<div id="params">Tone: ---</div>

<script>
let audioCtx;
let isPlaying = false;

// ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ‡æ›¿
let usePatternA = true;

// å¹³å‡BPMï¼ˆåˆæœŸå€¤ï¼‰
let smoothedBPM = 60;

// åŠ é€Ÿåº¦ã®å±¥æ­´
let motionHistory = [];
// è¦æœ›ã«åˆã‚ã›ã¦ã€Œ3ã€œ5ç§’ã€ã®ä¸­é–“ã‚’ã¨ã£ã¦4ç§’ã«è¨­å®š
const HISTORY_DURATION = 4000; 

// å°ç¯€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ç”¨
let nextBarTime = 0;

// ãƒ‘ã‚¿ãƒ¼ãƒ³å®šç¾©
const patterns = {
  A: ["D4","C4","B3","D4","C4","A3","G3","A3","B3"],
  B: ["D4","C4","B3","D4","C4","A3","G3","B3","G3"]
};

// ãƒªã‚ºãƒ ï¼ˆ4åˆ†ï¼1.0ï¼‰
const durations = [0.25,0.25,0.25,0.25,0.5,0.5,0.5,0.5,1.0];

// ---------------------------
// éŸ³åâ†’å‘¨æ³¢æ•°
// ---------------------------
function noteToFreq(note, offset = 0) {
  const map = {
    G3:-14, A3:-12, B3:-10,
    C4:-9,  D4:-7,  E4:-5, F4:-4, G4:-2, A4:0, B4:2,
    C5:3
  };
  let semitone = map[note] ?? 0;
  semitone += offset;
  return 440 * Math.pow(2, semitone/12);
}

document.getElementById("start").onclick = async () => {
  if (!audioCtx) {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  }
  if (audioCtx.state === "suspended") {
    await audioCtx.resume();
  }

  // iOS 13+ DeviceMotion Permission
  if (typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function") {
    try {
      const permissionState = await DeviceMotionEvent.requestPermission();
      if (permissionState !== 'granted') {
        alert("ã‚»ãƒ³ã‚µãƒ¼è¨±å¯ãŒå¿…è¦ã§ã™");
        return;
      }
    } catch (e) {
      console.error(e);
    }
  }

  window.addEventListener("devicemotion", handleMotion);
  document.getElementById("status").innerText = "æ­©è¡Œå¾…æ©Ÿä¸­(å¼·ã‚ã«æ­©ã„ã¦é–‹å§‹)...";
  document.getElementById("start").style.display = 'none';
};

// ---------------------------
// ã‚»ãƒ³ã‚µãƒ¼å‡¦ç† â†’ å¹³å‡BPMç®—å‡º
// ---------------------------
function handleMotion(e) {
  const acc = e.accelerationIncludingGravity; // Android/iOSå·®åˆ†å¸åã®ãŸã‚é‡åŠ›è¾¼ã¿ã‚’ä½¿ç”¨
  if (!acc) return;

  // é‡åŠ›è¾¼ã¿ã®ãƒ™ã‚¯ãƒˆãƒ«é•·ã‹ã‚‰ç°¡æ˜“çš„ã«å‹•ãã®å¤§ãã•ã‚’å–ã‚‹
  // (é™æ­¢æ™‚ã§ã‚‚9.8ä»˜è¿‘ã«ãªã‚‹ãŒã€ç›¸å¯¾å¤‰åŒ–ã‚’è¦‹ã‚‹ãŸã‚ç°¡æ˜“å®Ÿè£…)
  const mag = Math.sqrt(acc.x**2 + acc.y**2 + acc.z**2);
  const now = performance.now();

  motionHistory.push({time: now, val: mag});
  
  // å±¥æ­´æœŸé–“å¤–ã‚’å‰Šé™¤
  while(motionHistory.length > 0 && now - motionHistory[0].time > HISTORY_DURATION) {
    motionHistory.shift();
  }

  // å¹³å‡è¨ˆç®—
  let sum = 0;
  motionHistory.forEach(i => sum += i.val);
  const avg = sum / motionHistory.length || 0;

  // åŠ é€Ÿåº¦ã‹ã‚‰BPMã¸ã®ãƒãƒƒãƒ”ãƒ³ã‚°
  smoothedBPM = mapAccelToBPM(avg);

  // ãƒ‡ãƒãƒƒã‚°è¡¨ç¤º
  const isHigh = smoothedBPM >= 110;
  document.getElementById("debug").innerText = 
    `Avg BPM: ${Math.floor(smoothedBPM)} ${isHigh?"ğŸ”¥Active":""}`;

  // éŸ³è‰²ã®ãƒ‡ãƒãƒƒã‚°è¡¨ç¤ºï¼ˆä»Šã®BPMã§ã©ã†ã„ã†ãƒ•ã‚£ãƒ«ã‚¿ã«ãªã‚‹ã‹ï¼‰
  const fInfo = getFilterParams(smoothedBPM);
  document.getElementById("params").innerText = 
    `Cutoff: ${Math.floor(fInfo.freq)}Hz (${fInfo.desc})  â—¦ Synth: ${synthDescriptor(smoothedBPM)}`;

  // é–‹å§‹ãƒˆãƒªã‚¬ãƒ¼ï¼ˆé–¾å€¤ã¯ãƒ‡ãƒã‚¤ã‚¹ã«ã‚ˆã£ã¦èª¿æ•´ãŒå¿…è¦ã‹ã‚‚ã—ã‚Œã¾ã›ã‚“ï¼‰
  // é‡åŠ›åˆ†(ç´„9.8) + å‹•ãåˆ†ã€‚ã“ã“ã§ã¯13ç¨‹åº¦ã‚’é–¾å€¤ã«è¨­å®š
  if (!isPlaying && mag > 13) {
    startSequence();
  }
}

function synthDescriptor(bpm){
  if (bpm >= 120) return "PolyMono (square8-like)";
  if (bpm >= 110) return "FM (bright)";
  if (bpm >= 100) return "PolyTri (soft)";
  return "Soft Simple";
}

function mapAccelToBPM(a) {
  // é‡åŠ›åˆ†(ç´„9.8)ã‚’å¼•ã„ãŸã€Œå‹•ãæˆåˆ†ã€ã§è¨ˆç®—
  let val = a - 9.8; 
  if (val < 0) val = 0;

  // ä¿‚æ•°ã¯æ­©ãæ–¹ã«åˆã‚ã›ã¦èª¿æ•´
  let bpm = 60 + (val * 15); 

  if (bpm < 60) bpm = 60;
  if (bpm > 180) bpm = 180;
  return bpm;
}

// ---------------------------
// ãƒ•ã‚£ãƒ«ã‚¿ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã®ç®—å‡º
// ---------------------------
function getFilterParams(bpm) {
  let t = (bpm - 60) / (140 - 60); // 0.0 ã€œ 1.0
  if (t < 0) t = 0;
  if (t > 1) t = 1;

  const minFreq = 300;
  const maxFreq = 1000;
  const freq = minFreq * Math.pow(maxFreq / minFreq, t);
  const q = 1 + t * 4; 

  let desc = "Soft/Muffled";
  if (t > 0.4) desc = "Medium";
  if (t > 0.8) desc = "Bright/Brass";

  return { freq, q, desc };
}

// ---------------------------
// ã‚·ãƒ¼ã‚±ãƒ³ã‚¹é–‹å§‹
// ---------------------------
function startSequence() {
  isPlaying = true;
  nextBarTime = audioCtx.currentTime + 0.1; 
  document.getElementById("status").innerText = "å†ç”Ÿä¸­";
}

// ---------------------------
// 1å°ç¯€ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°
// ---------------------------
function scheduleBar() {
  const pattern = usePatternA ? patterns.A : patterns.B;
  // å°ç¯€ã®é•·ã•ã¯ã€Œãã®ç¬é–“ã® smoothedBPMã€ã‚’å…ƒã«æ±ºã‚ã‚‹ãŒ
  // éŸ³è‰² (synth) ã¯å°ç¯€é–‹å§‹æ™‚ã® BPM ã«åŸºã¥ã„ã¦çµ±ä¸€ã™ã‚‹ï¼ˆå°ç¯€æ¯ã«éŸ³è‰²åˆ‡æ›¿ï¼‰
  const currentBarBPM = smoothedBPM;
  const beatDur = 60 / currentBarBPM; // ã“ã®æ™‚ç‚¹ã®BPMã§å°ç¯€ã®é•·ã•ã‚’æ±ºå®š
  const now = audioCtx.currentTime;
  
  const filterParams = getFilterParams(currentBarBPM);

  if (nextBarTime < now) {
    nextBarTime = now + 0.05;
  }

  let cursor = nextBarTime;

  for (let i = 0; i < pattern.length; i++) {
    const beatLen = durations[i];
    const durSec = beatLen * beatDur;

    const freq = noteToFreq(pattern[i], 0);

    // BPMã«å¿œã˜ãŸã€ŒéŸ³æ§‹æˆã€ã‚’é©ç”¨ï¼ˆplayTone ã« BPM ã‚’æ¸¡ã™ï¼‰
    playTone(freq, cursor, durSec, filterParams, currentBarBPM);
    
    cursor += durSec;
  }

  // æ¬¡ã®å°ç¯€é ­ã¸
  const totalBeats = durations.reduce((a,b)=>a+b, 0);
  nextBarTime += totalBeats * beatDur;

  usePatternA = !usePatternA;
}

// ---------------------------
// éŸ³å†ç”Ÿï¼ˆBPMãƒ¬ãƒ³ã‚¸ã«å¿œã˜ã¦éŸ³è‰²ã‚’åˆ†å²ã€Tone.js ã§ã¯ãªã WebAudioã§å†ç¾ï¼‰
// - ç¬¬5å¼•æ•° bpm ã‚’ä½¿ã£ã¦ 3ãƒ¬ãƒ³ã‚¸ã‚’åˆ‡æ›¿ï¼ˆæç¤ºã•ã‚ŒãŸ Tone è¨­å®šã‚’è¿‘ä¼¼ï¼‰
// ---------------------------
function playTone(freq, time, dur, fParams, bpm) {
  // common gain target
  const maxGain = 0.4;

  if (bpm >= 120) {
    // --- BPM120ä»¥ä¸Š: PolySynth(MonoSynth) ã«è¿‘ã„æŒ™å‹•ï¼ˆsquare8é¢¨ï¼‰ ---
    // å®Ÿè£…: 2å°ã®ã‚ªã‚·ãƒ¬ãƒ¼ã‚¿ï¼ˆå°‘ã—ãƒ‡ãƒãƒ¥ãƒ¼ãƒ³ï¼‰ + ãƒ­ãƒ¼ãƒ‘ã‚¹ + ãƒ•ã‚£ãƒ«ã‚¿ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—
    const osc1 = audioCtx.createOscillator();
    const osc2 = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    osc1.type = "square";
    osc2.type = "square";
    osc1.frequency.value = freq;
    osc2.frequency.value = freq * 1.0015; // å¾®ãƒ‡ãƒãƒ¥ãƒ¼ãƒ³

    filter.type = "lowpass";
    filter.frequency.value = fParams.freq; // base
    filter.Q.value = fParams.q;

    // æ¥ç¶š
    osc1.connect(filter);
    osc2.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);

    // ãƒ•ã‚£ãƒ«ã‚¿ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—ï¼ˆæç¤ºå€¤ã‚’è¿‘ä¼¼ï¼‰
    // attack:0.001 -> æ€¥é€Ÿã«é–‹ã, decay:0.7, sustain:0.1, release:0.8
    const now = time;
    filter.frequency.setValueAtTime(fParams.freq * 0.2, now);
    filter.frequency.linearRampToValueAtTime(fParams.freq, now + 0.05);
    // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒªãƒ¼ã‚¹ã¯å˜ç´”ã«ãƒ•ã‚§ãƒ¼ãƒ‰ã•ã›ã‚‹ï¼ˆç·šå½¢ï¼‰
    filter.frequency.linearRampToValueAtTime(fParams.freq * 0.3, now + dur * 0.9);

    // éŸ³é‡ã‚¨ãƒ³ãƒ™ãƒ­ãƒ¼ãƒ—
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(maxGain * 0.9, now + 0.05); // attack 0.05
    gain.gain.exponentialRampToValueAtTime(0.001, now + dur);

    osc1.start(time);
    osc2.start(time);
    osc1.stop(time + dur);
    osc2.stop(time + dur);

    // cleanup - disconnect after stop
    setTimeout(() => {
      try { osc1.disconnect(); osc2.disconnect(); filter.disconnect(); gain.disconnect(); } catch(e){}
    }, (time - audioCtx.currentTime + dur + 0.2) * 1000);

    return;
  }

  if (bpm >= 110) {
    // --- BPM110~119: FMSynth ã£ã½ã„æŒ™å‹•ã‚’ç°¡æ˜“å®Ÿè£… ---
    // è¨­å®šã‚’è¿‘ä¼¼:
    // harmonicity: 3, modulationIndex: ~12.22
    // modulation type: square
    // envelope: attack:0.01, decay:0.2, sustain:1, release:0.5
    // modulationEnvelope: attack:0.2, decay:0.01, sustain:1, release:0.5

    const carrier = audioCtx.createOscillator();
    const mod = audioCtx.createOscillator();
    const modGain = audioCtx.createGain();
    const gain = audioCtx.createGain();
    const filter = audioCtx.createBiquadFilter();

    // carrier / mod types
    carrier.type = "sawtooth";
    mod.type = "square";

    carrier.frequency.value = freq;
    // harmonicity 3 => mod frequency = carrier * 3
    const harmonicity = 3;
    mod.frequency.value = freq * harmonicity;

    // modulation index scaling -> modulation amplitude in Hz
    // 12.22 ã‚’ãã®ã¾ã¾ä½¿ã†ã¨å¤§ãã™ãã‚‹ã®ã§ã‚¹ã‚±ãƒ¼ãƒ«ãƒ€ã‚¦ãƒ³ empirically
    const modulationIndex = 12.22;
    modGain.gain.setValueAtTime(0, time); // will be ramped by modulation envelope

    // connect mod -> modGain -> carrier.frequency
    mod.connect(modGain);
    modGain.connect(carrier.frequency);

    // filter to shape tone
    filter.type = "lowpass";
    filter.frequency.value = fParams.freq;
    filter.Q.value = fParams.q;

    carrier.connect(filter);
    filter.connect(gain);
    gain.connect(audioCtx.destination);

    // carrier amplitude envelope
    const now = time;
    gain.gain.setValueAtTime(0.0001, now);
    gain.gain.linearRampToValueAtTime(maxGain * 0.6, now + 0.01); // attack 0.01
    gain.gain.exponentialRampToValueAtTime(0.0001, now + dur + 0.01);

    // modulation envelope (ramp modGain.gain from 0 to modulationIndexScale)
    // use modulationEnvelope attack 0.2s fast for this context but clipped to note length
    const modEnvAttack = Math.min(0.2, dur * 0.5);
    const modEnvDecay = 0.01;
    const modTarget = modulationIndex * 1.2; // scale factor to sound reasonable

    modGain.gain.setValueAtTime(0.0001, now);
    modGain.gain.linearRampToValueAtTime(modTarget, now + modEnvAttack);
    // small decay to sustain
    modGain.gain.linearRampToValueAtTime(modTarget * 0.9, now + modEnvAttack + modEnvDecay);
    // release
    modGain.gain.exponentialRampToValueAtTime(0.0001, now + dur + 0.05);

    // start/stop
    mod.start(time - 0.01);
    carrier.start(time - 0.01);
    mod.stop(time + dur + 0.02);
    carrier.stop(time + dur + 0.02);

    // cleanup
    setTimeout(() => {
      try { mod.disconnect(); modGain.disconnect(); carrier.disconnect(); filter.disconnect(); gain.disconnect(); } catch(e){}
    }, (time - audioCtx.currentTime + dur + 0.4) * 1000);

    return;
  }

  // --- BPM100~109: PolySynth(Tone.Synth) ã«è¿‘ã„æŸ”ã‚‰ã‹ã„ä¸‰è§’æ³¢ ---
  // emulate: triangle oscillator, envelope attack:0.005, decay:0.1, sustain:0.3, release:1

  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  const filter = audioCtx.createBiquadFilter();

  osc.type = "triangle";
  osc.frequency.value = freq;

  // gentle lowpass to mellow
  filter.type = "lowpass";
  filter.frequency.value = fParams.freq * 0.7;
  filter.Q.value = fParams.q * 0.6;

  osc.connect(filter);
  filter.connect(gain);
  gain.connect(audioCtx.destination);

  const now = time;
  // envelope
  const a = 0.005;
  const d = 0.1;
  const s = 0.3;
  const r = 1.0;

  gain.gain.setValueAtTime(0.0001, now);
  gain.gain.linearRampToValueAtTime(maxGain * 0.5, now + a);
  // decay to sustain level
  const sustainLevel = maxGain * s;
  gain.gain.linearRampToValueAtTime(sustainLevel, now + a + d);
  // release
  gain.gain.exponentialRampToValueAtTime(0.0001, now + dur + r * 0.1);

  osc.start(time);
  osc.stop(time + dur + 0.05);

  // cleanup
  setTimeout(() => {
    try { osc.disconnect(); filter.disconnect(); gain.disconnect(); } catch(e){}
  }, (time - audioCtx.currentTime + dur + 0.4) * 1000);
}

// ---------------------------
// ãƒ«ãƒ¼ãƒ—ç›£è¦–
// ---------------------------
setInterval(() => {
  if (!isPlaying) return;
  const now = audioCtx.currentTime;
  // å…ˆèª­ã¿
  if (nextBarTime - now < 0.1) {
    scheduleBar();
  }
}, 25);
</script>

</body>
</html>
// ...existing code...